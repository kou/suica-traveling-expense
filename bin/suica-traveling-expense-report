#!/usr/bin/env ruby
#
# Copyright (C) 2018  Kouhei Sutou <kou@clear-code.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Some codes in this program are learned from gsuica:
#
#   http://hito.music.coocan.jp/pasori/gsuica.html
#
# Here is the license of gsuica:
#
#   Copyright (C) 2005-2006, Hiroyuki Ito. ZXB01226@nifty.com
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
#   USA.

require "optparse"

require "pasori"

class SuicaTravelingExpenseReporter
  class RawData
    attr_accessor :idm
    attr_reader :in_out
    attr_reader :history
    def initialize
      @idm = nil
      @in_out = []
      @history = []
    end
  end

  def initialize
    @raw_data = RawData.new
    @raw_data_output_path = nil
    @raw_data_input_path = nil
  end

  def run(argv)
    parser = OptionParser.new
    parser.on("--output-raw-data=PATH",
              "Output raw data to PATH") do |path|
      @raw_data_output_path = path
    end
    parser.on("--input-raw-data=PATH",
              "Read raw data from PATH") do |path|
      @raw_data_input_path = path
    end
    parser.parse!(argv)

    report
  end

  def report
    raw_data = read_raw_data
    raw_data.in_out.each do |in_out|
      p [:in_out, in_out, parse_in_out(in_out)]
    end
    raw_data.history.each do |history|
      p [:history, history, parse_history(history)]
    end

    true
  end

  private
  def read_raw_data
    if @raw_data_input_path.nil?
      Pasori.open do |pasori|
        felica = pasori.felica_polling(Felica::POLLING_SUICA)
        if felica.nil?
          raise "No Suica found."
        end

        @raw_data.idm = felica.idm

        felica.foreach(Felica::SERVICE_SUICA_IN_OUT) do |data|
          @raw_data.in_out << data
        end

        felica.foreach(Felica::SERVICE_SUICA_HISTORY) do |data|
          @raw_data.history << data
        end

        save_raw_data
      end
    else
      File.open(@raw_data_input_path, "rb") do |file|
        @raw_data = Marshal.load(file)
      end
    end

    @raw_data
  end

  def save_raw_data
    return if @raw_data_output_path.nil?

    File.open(@raw_data_output_path, "wb") do |file|
      file.write(Marshal.dump(@raw_data))
    end
  end

  def parse_in_out(raw_data)
    type, line, station, _, _, date, time, expense, region =
      raw_data.unpack("nCCCCnnvN")
    timestamp = parse_timestamp(date, time)
    p [type, line, station, date, time, expense, region, timestamp]
    case type
    when 0xA000
      in_data = true
      p :in
    else
      out_data = true
      p :out
    end
  end

  TERMINAL_TYPES = {
    0x03 => "精算機",
    0x05 => "車載端末",
    0x07 => "券売機",
    0x08 => "券売機",
    0x09 => "入金機",
    0x12 => "券売機",
    0x14 => "券売機等",
    0x15 => "券売機等",
    0x16 => "改札機",
    0x17 => "簡易改札機",
    0x18 => "窓口端末",
    0x19 => "窓口端末",
    0x1A => "改札端末",
    0x1B => "携帯電話",
    0x1C => "乗継精算機",
    0x1D => "連絡改札機",
    0x1F => "簡易入金機",
    0x23 => "新幹線改札機",
    0x46 => "VIEW ALTTE",
    0x48 => "VIEW ALTTE",
    0xC7 => "物販端末",
    0xC8 => "自販機",
  }

  def parse_history(raw_data)
    terminal, manage_type = raw_data.unpack("CC")
    terminal_name = TERMINAL_TYPES[terminal]

    case terminal_name
    when "物販端末", "自販機"
    when "車載端末"
    else
      _, _, _, date, in_line, in_station, out_line, out_station, balance, region_and_number =
        raw_data.unpack("CCnnCCCCvN")
      region = (region_and_number >> 4) & 0x0F
      number = (region_and_number >> 8)
      timestamp = parse_timestamp(date, 0)
      p [terminal, manage_type, date, in_line, in_station, out_line, out_station, balance, region, number, timestamp]
    end
  end

  def parse_timestamp(raw_date, raw_time)
    year = (raw_date >> 9) + 2000
    month = (raw_date >> 5) & 0x0F
    day = raw_date & 0x1F
    hour = ("%x" % (raw_time >> 8)).to_i
    minute = ("%x" % (raw_time & 0xFF)).to_i
    Time.local(year, month, day, hour, minute)
  end
end

reporter = SuicaTravelingExpenseReporter.new
exit(reporter.run(ARGV))
